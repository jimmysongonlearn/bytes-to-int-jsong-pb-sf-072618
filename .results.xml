<?xml version="1.0" encoding="utf-8"?><testsuite errors="0" failures="1" name="pytest" skips="0" tests="2" time="0.684"><testcase classname="test.index_test.HelperTest" file="test/index_test.py" line="13" name="test_int_to_little_endian" time="0.0017273426055908203"><failure message="TypeError: to_bytes() argument 2 must be str, not int">self = &lt;index_test.HelperTest testMethod=test_int_to_little_endian&gt;

    def test_int_to_little_endian(self):
        n = 1
        want = b&apos;\x01\x00\x00\x00&apos;
&gt;       self.assertEqual(int_to_little_endian(n, 4), want)

test/index_test.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

n = 1, length = 4

    &quot;metadata&quot;: {},
    &quot;source&quot;: [
     &quot;## Converting from bytes to int and back\n&quot;,
     &quot;\n&quot;,
&gt;    &quot;Converting from bytes to integer requires learning about Big and Little Endian encoding. Essentially any number greater than 255 can be encoded in two ways, with the \&quot;Big End\&quot; going first or the \&quot;Little End\&quot; going first.\n&quot;,
     &quot;\n&quot;,
     &quot;Normal human reading is from the \&quot;Big End\&quot;. For example 123 is read as 100 + 20 + 3. Some computer systems encode integers with the \&quot;Little End\&quot; first.\n&quot;,
     &quot;\n&quot;,
     &quot;A number like 500 is encoded this way in Big Endian:\n&quot;,
     &quot;\n&quot;,
     &quot;0x01f4 (256 + 244)\n&quot;,
     &quot;\n&quot;,
     &quot;But this way in Little Endian:\n&quot;,
     &quot;\n&quot;,
     &quot;0xf401 (244 + 256)\n&quot;,
     &quot;\n&quot;,
     &quot;In Python we can convert an integer to big or little endian using a built-in method:\n&quot;,
     &quot;\n&quot;,
     &quot;```python\n&quot;,
     &quot;n = 1234567890\n&quot;,
     &quot;big_endian = n.to_bytes(4, &apos;big&apos;)  # b&apos;\\x49\\x96\\x02\\xd2&apos;\n&quot;,
     &quot;little_endian = n.to_bytes(4, &apos;little&apos;)  # b&apos;\\xd2\\x02\\x96\\x49&apos;\n&quot;,
     &quot;```\n&quot;,
     &quot;\n&quot;,
     &quot;We can also convert from bytes to an integer this way:\n&quot;,
     &quot;\n&quot;,
     &quot;```python\n&quot;,
     &quot;big_endian = b&apos;\\x49\\x96\\x02\\xd2&apos;\n&quot;,
     &quot;n = int.from_bytes(big_endian, &apos;big&apos;)  # 1234567890\n&quot;,
     &quot;little_endian = b&apos;\\xd2\\x02\\x96\\x49&apos;\n&quot;,
     &quot;n = int.from_bytes(little_endian, &apos;little&apos;)  # 1234567890\n&quot;,
     &quot;```&quot;
    ]
      },
      {
       &quot;cell_type&quot;: &quot;code&quot;,
       &quot;execution_count&quot;: 6,
       &quot;metadata&quot;: {},
       &quot;outputs&quot;: [
        {
         &quot;name&quot;: &quot;stdout&quot;,
         &quot;output_type&quot;: &quot;stream&quot;,
         &quot;text&quot;: [
          &quot;499602d2\n&quot;,
          &quot;d2029649\n&quot;,
          &quot;1234567890\n&quot;,
          &quot;1234567890\n&quot;
         ]
        }
       ],
       &quot;source&quot;: [
        &quot;n = 1234567890\n&quot;,
        &quot;big_endian = n.to_bytes(4, &apos;big&apos;)\n&quot;,
        &quot;little_endian = n.to_bytes(4, &apos;little&apos;)\n&quot;,
        &quot;\n&quot;,
        &quot;print(big_endian.hex())\n&quot;,
        &quot;print(little_endian.hex())\n&quot;,
        &quot;\n&quot;,
        &quot;print(int.from_bytes(big_endian, &apos;big&apos;))\n&quot;,
        &quot;print(int.from_bytes(little_endian, &apos;little&apos;))&quot;
       ]
      },
      {
       &quot;cell_type&quot;: &quot;markdown&quot;,
       &quot;metadata&quot;: {},
       &quot;source&quot;: [
        &quot;### Try it\n&quot;,
        &quot;\n&quot;,
        &quot;Convert the following:\n&quot;,
        &quot;\n&quot;,
        &quot; * 8675309 to 8 bytes in big endian\n&quot;,
        &quot; * interpret ```b&apos;\\x11\\x22\\x33\\x44\\x55&apos;``` as a little endian integer&quot;
       ]
      },
      {
       &quot;cell_type&quot;: &quot;code&quot;,
       &quot;execution_count&quot;: 3,
       &quot;metadata&quot;: {},
       &quot;outputs&quot;: [
        {
         &quot;name&quot;: &quot;stdout&quot;,
         &quot;output_type&quot;: &quot;stream&quot;,
         &quot;text&quot;: [
          &quot;b&apos;\\x00\\x00\\x00\\x00\\x00\\x84_\\xed&apos;\n&quot;,
          &quot;366216421905\n&quot;
         ]
        }
       ],
       &quot;source&quot;: [
        &quot;n = 8675309\n&quot;,
        &quot;# print n in 8 big endian bytes\n&quot;,
        &quot;print(n.to_bytes(8, &apos;big&apos;))\n&quot;,
        &quot;\n&quot;,
        &quot;little_endian = b&apos;\\x11\\x22\\x33\\x44\\x55&apos;\n&quot;,
        &quot;# print little endian in decimal\n&quot;,
        &quot;print(int.from_bytes(little_endian, &apos;little&apos;))&quot;
       ]
      },
      {
       &quot;cell_type&quot;: &quot;markdown&quot;,
       &quot;metadata&quot;: {},
       &quot;source&quot;: [
        &quot;### Test Driven Exercise\n&quot;,
        &quot;\n&quot;,
        &quot;Add `little_endian_to_int()` and `int_to_little_endian()` methods to your library.&quot;
       ]
      },
      {
       &quot;cell_type&quot;: &quot;code&quot;,
       &quot;execution_count&quot;: 2,
       &quot;metadata&quot;: {},
       &quot;outputs&quot;: [],
       &quot;source&quot;: [
        &quot;def little_endian_to_int(b):\n&quot;,
        &quot;    &apos;&apos;&apos;little_endian_to_int takes byte sequence as a little-endian number.\n&quot;,
        &quot;    Returns an integer&apos;&apos;&apos;\n&quot;,
        &quot;    # use the from_bytes method of int\n&quot;,
        &quot;    return int.from_bytes(b, &apos;little&apos;)\n&quot;,
        &quot;\n&quot;,
        &quot;def int_to_little_endian(n, length):\n&quot;,
        &quot;    &apos;&apos;&apos;endian_to_little_endian takes an integer and returns the little-endian\n&quot;,
        &quot;    byte sequence of length&apos;&apos;&apos;\n&quot;,
        &quot;    # use the to_bytes method of n\n&quot;,
        &quot;    return n.to_bytes(length, 4)&quot;
       ]
      },
      {
       &quot;cell_type&quot;: &quot;code&quot;,
       &quot;execution_count&quot;: null,
       &quot;metadata&quot;: {},
       &quot;outputs&quot;: [],
       &quot;source&quot;: []
      }
     ],
     &quot;metadata&quot;: {
      &quot;kernelspec&quot;: {
       &quot;display_name&quot;: &quot;Python 3&quot;,
       &quot;language&quot;: &quot;python&quot;,
       &quot;name&quot;: &quot;python3&quot;
      },
      &quot;language_info&quot;: {
       &quot;codemirror_mode&quot;: {
        &quot;name&quot;: &quot;ipython&quot;,
        &quot;version&quot;: 3
       },
       &quot;file_extension&quot;: &quot;.py&quot;,
       &quot;mimetype&quot;: &quot;text/x-python&quot;,
       &quot;name&quot;: &quot;python&quot;,
       &quot;nbconvert_exporter&quot;: &quot;python&quot;,
       &quot;pygments_lexer&quot;: &quot;ipython3&quot;,
       &quot;version&quot;: &quot;3.6.6&quot;
      }
     },
     &quot;nbformat&quot;: 4,
     &quot;nbformat_minor&quot;: 2
    }
E   TypeError: to_bytes() argument 2 must be str, not int

index.ipynb:152: TypeError</failure></testcase><testcase classname="test.index_test.HelperTest" file="test/index_test.py" line="5" name="test_little_endian_to_int" time="0.0010864734649658203"></testcase></testsuite>